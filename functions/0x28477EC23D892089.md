# GRAPHICS::DRAW_MARKER

## Summary
Draws a marker this frame

## Parameters
* **MARKER_TYPE** markerType: The type of marker to the drawn scrVecPosition - position of the marker scrVecDirection - the direction the marker should face scrVecRotation - the rotation applied to the marker (in degrees for each axis) scrVecScale - the scale of the marker in each of the 3 dimensions col - the colour of the marker (0-255 for each component)
* **FLOAT** scrVecPositionX
* **FLOAT** scrVecPositionY
* **FLOAT** scrVecPositionZ
* **FLOAT** scrVecDirectionX
* **FLOAT** scrVecDirectionY
* **FLOAT** scrVecDirectionZ
* **FLOAT** scrVecRotationX
* **FLOAT** scrVecRotationY
* **FLOAT** scrVecRotationZ
* **FLOAT** scrVecScaleX
* **FLOAT** scrVecScaleY
* **FLOAT** scrVecScaleZ
* **INT** colR = 255
* **INT** colG = 100
* **INT** colB = 0
* **INT** colA = 100
* **BOOL** bounce = false: Whether the marker should bounce up and down
* **BOOL** faceCam = false: Whether the marker should face the camera
* **EULER_ROT_ORDER** rotOrder = 2
* **BOOL** rotate = false: Whether the marker should rotate automatically on the Z axis.
* **STRING** txdName = null: Streamed texture dictionary name
* **STRING** texName = null: Streamed texture name
* **BOOL** invert = false: Render inverted

## Description
<!-- AUTOGENERATED: Remove this line before editing -->
enum MarkerTypes
{
    MarkerTypeUpsideDownCone = 0,
 MarkerTypeVerticalCylinder = 1,
   MarkerTypeThickChevronUp = 2,
 MarkerTypeThinChevronUp = 3,
  MarkerTypeCheckeredFlagRect = 4,
  MarkerTypeCheckeredFlagCircle = 5,
    MarkerTypeVerticleCircle = 6,
 MarkerTypePlaneModel = 7,
 MarkerTypeLostMCDark = 8,
 MarkerTypeLostMCLight = 9,
    MarkerTypeNumber0 = 10,
   MarkerTypeNumber1 = 11,
   MarkerTypeNumber2 = 12,
   MarkerTypeNumber3 = 13,
   MarkerTypeNumber4 = 14,
   MarkerTypeNumber5 = 15,
   MarkerTypeNumber6 = 16,
   MarkerTypeNumber7 = 17,
   MarkerTypeNumber8 = 18,
   MarkerTypeNumber9 = 19,
   MarkerTypeChevronUpx1 = 20,
   MarkerTypeChevronUpx2 = 21,
   MarkerTypeChevronUpx3 = 22,
   MarkerTypeHorizontalCircleFat = 23,
   MarkerTypeReplayIcon = 24,
    MarkerTypeHorizontalCircleSkinny = 25,
    MarkerTypeHorizontalCircleSkinny_Arrow = 26,
  MarkerTypeHorizontalSplitArrowCircle = 27,
    MarkerTypeDebugSphere = 28,
   MarkerTypeDallorSign = 29,
    MarkerTypeHorizontalBars = 30,
    MarkerTypeWolfHead = 31
};

dirX/Y/Z represent a heading on each axis in which the marker should face, alternatively you can rotate each axis independently with rotX/Y/Z (and set dirX/Y/Z all to 0).

faceCamera - Rotates only the y-axis (the heading) towards the camera

p19 - no effect, default value in script is 2

rotate - Rotates only on the y-axis (the heading)

textureDict - Name of texture dictionary to load texture from (e.g. "GolfPutting")

textureName - Name of texture inside dictionary to load (e.g. "PuttingMarker")

drawOnEnts - Draws the marker onto any entities that intersect it

basically what he said, except textureDict and textureName are totally not const char*, or if so, then they are always set to 0/NULL/nullptr in every script I checked, eg:

bj.c: graphics::draw_marker(6, vParam0, 0f, 0f, 1f, 0f, 0f, 0f, 4f, 4f, 4f, 240, 200, 80, iVar1, 0, 0, 2, 0, 0, 0, false);

his is what I used to draw an amber downward pointing chevron "V", has to be redrawn every frame.  The 180 is for 180 degrees rotation around the Y axis, the 50 is alpha, assuming max is 100, but it will accept 255.

GRAPHICS::DRAW_MARKER(2, v.x, v.y, v.z + 2, 0, 0, 0, 0, 180, 0, 2, 2, 2, 255, 128, 0, 50, 0, 1, 1, 0, 0, 0, 0);

